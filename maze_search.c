#include<stdio.h>
#include<stdlib.h>
#include<time.h>

//どちらも5以上の奇数にすること。
#define max_y 9
#define max_x 9

int main(void)
{
  int field[max_y][max_x]; //フィールド（0が通路で、1が壁。）
  int y; //フィールド配列の縦の要素番号
  int x; //フィールド配列の横の要素番号
  int r; //乱数の値

  srand((unsigned)time(NULL)); //乱数の仕組みを初期化。

  //通路（0）の生成
  for(y=0; y<max_y; y=y+1) //フィールドの縦幅の分だけループする。
  {
    for(x=0; x<max_x; x=x+1) //フィールドの横幅の分だけループする。
    {
      field[y][x] = 0;
    }
  }

  //上下の外壁（1）の生成
  for(x=0; x<max_x; x=x+1) //フィールドの横幅の分だけループする。
  {
    field[0][x] = 1;
    field[max_y-1][x] = 1;
  }

  //左右の外壁（1）の生成
  for(y=0; y<max_y; y=y+1) //フィールドの縦幅の分だけループする。
  {
    field[y][0] = 1;
    field[y][max_x-1] = 1;
  }

  //棒倒し法を使った壁（1）の生成（1行めのみ）
  y = 2; //1行め
  for(x=2; x<max_x-1; x=x+2) //xの要素番号2から要素番号max_x-1まで、1マス飛ばしで棒倒し。
  {
    r = (rand()%12) + 1; //乱数生成（r = 1から12のランダムな値）
    field[y][x] = 1; //中心から……
    if(r>=1 && r<=3) //rが1から3のとき
    {
      if(field[y-1][x]==0) //上に棒（壁）がなければ
      {
        field[y-1][x] = 1; //上に棒を倒す。
      }
      else if(field[y-1][x]==1) //上に棒（壁）があれば
      {
        x = x - 2; //棒を倒さずに、乱数生成をやり直す。
      }
    }
    if(r>=4 && r<=6) //rが4から6のとき
    {
      if(field[y+1][x]==0) //下に棒（壁）がなければ
      {
        field[y+1][x] = 1; //下に棒を倒す。
      }
      else if(field[y+1][x]==1) //下に棒（壁）があれば
      {
        x = x - 2; //棒を倒さずに、乱数生成をやり直す。
      }
    }
    if(r>=7 && r<=9) //rが7から9のとき
    {
      if(field[y][x-1]==0) //左に棒（壁）がなければ
      {
        field[y][x-1] = 1; //左に棒を倒す。
      }
      else if(field[y][x-1]==1) //左に棒（壁）があれば
      {
        x = x - 2; //棒を倒さずに、乱数生成をやり直す。
      }
    }
    if(r>=10 && r<=12) //rが10から12のとき
    {
      if(field[y][x+1]==0) //右に棒（壁）がなければ
      {
        field[y][x+1] = 1; //右に棒を倒す。
      }
      else if(field[y][x+1]==1) //右に棒（壁）があれば
      {
        x = x - 2; //棒を倒さずに、乱数生成をやり直す。
      }
    }
  }

     for(y=4; y<max_y-1; y=y+2) //yの要素番号4から要素番号max_y-1まで、1マス飛ばしで棒倒し。
  {
    for(x=2; x<max_x-1; x=x+2) //xの要素番号2から要素番号max_x-1まで、1マス飛ばしで棒倒し。
    {
      r = (rand()%12) + 1; //乱数生成（r = 1から12のランダムな値）
      field[y][x] = 1; //中心から……
      if(r>=1 && r<=4) //rが1から4のとき
      {
        if(field[y+1][x]==0) //下に棒（壁）がなければ
        {
          field[y+1][x] = 1; //下に棒を倒す。
        }
        else if(field[y+1][x]==1) //下に棒（壁）があれば
        {
          x = x - 2; //棒を倒さずに、乱数生成をやり直す。
        }
      }
      if(r>=5 && r<=8) //rが5から8のとき
      {
        if(field[y][x-1]==0) //左に棒（壁）がなければ
        {
          field[y][x-1] = 1; //左に棒を倒す。
        }
        else if(field[y][x-1]==1) //左に棒（壁）があれば
        {
          x = x - 2; //棒を倒さずに、乱数生成をやり直す。
        }
      }
      if(r>=9 && r<=12) //rが9から12のとき
      {
        if(field[y][x+1]==0) //右に棒（壁）がなければ
        {
          field[y][x+1] = 1; //右に棒を倒す。
        }
        else if(field[y][x+1]==1) //右に棒（壁）があれば
        {
          x = x - 2; //棒を倒さずに、乱数生成をやり直す。
        }
      }
    }
  }
  
  field[0][1] = 0; //スタート地点の壁を撤去する。
  field[max_y-1][max_x-2] = 0; //ゴール地点の壁を撤去する。

  //結果表示
  for(y=0; y<max_y; y=y+1) //フィールドの縦幅の分だけループする。
  {
    for(x=0; x<max_x; x=x+1) //フィールドの横幅の分だけループする。
    {
      if(field[y][x]==0) //通路なら
      {
        printf("%2s","  "); //空白で表す。
      }
      else if(field[y][x]==1) //壁なら
      {
        printf("%2s","1"); //四角形で表す。
      }
    }
    printf("\n"); //行の終了時点で改行する。
  }

  return(0);
}

